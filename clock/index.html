<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>时钟转转乐 - 互动式数位教具</title>
    
    <!-- 引入 React 和 ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- 引入 Babel 用于编译 JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- 引入 Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- 引入 Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;700&family=Orbitron:wght@700&family=VT323&display=swap" rel="stylesheet">

    <style>
        body {
            font-family: 'Noto Sans TC', sans-serif;
            overscroll-behavior: none;
        }
        .font-orbitron { font-family: 'Orbitron', sans-serif; }
        .font-vt323 { font-family: 'VT323', monospace; }

        input[type=range] {
            -webkit-appearance: none; 
            background: transparent; 
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px; 
            width: 20px;
            border-radius: 50%;
            background: #4F46E5;
            cursor: pointer;
            margin-top: -8px; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #E2E8F0;
            border-radius: 2px;
        }
    </style>
    
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    screens: {
                        'xs': '375px', 
                    }
                }
            }
        }
    </script>
</head>
<body class="bg-slate-100 text-slate-800">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useCallback, useMemo, useLayoutEffect } = React;

        // --- 图示组件 (SVG) ---
        const IconBase = ({ children, className, ...props }) => (
            <svg 
                xmlns="http://www.w3.org/2000/svg" 
                viewBox="0 0 24 24" 
                fill="none" 
                stroke="currentColor" 
                strokeWidth="2" 
                strokeLinecap="round" 
                strokeLinejoin="round" 
                className={className} 
                {...props}
            >
                {children}
            </svg>
        );

        const MousePointer2 = (props) => <IconBase {...props}><path d="m12 6 4 13.4-4.4-3.6-3.6 4.4Z"/></IconBase>;

        // --- 七笔画显示组件 ---
        const SevenSegmentDigit = ({ value, color = '#111827', inactiveColor = '#F3F4F6', className }) => {
          const SEGMENTS = {
            0: [1, 1, 1, 1, 1, 1, 0],
            1: [0, 1, 1, 0, 0, 0, 0],
            2: [1, 1, 0, 1, 1, 0, 1],
            3: [1, 1, 1, 1, 0, 0, 1],
            4: [0, 1, 1, 0, 0, 1, 1],
            5: [1, 0, 1, 1, 0, 1, 1],
            6: [1, 0, 1, 1, 1, 1, 1],
            7: [1, 1, 1, 0, 0, 0, 0], 
            8: [1, 1, 1, 1, 1, 1, 1],
            9: [1, 1, 1, 1, 0, 1, 1], 
          };

          const activeSegments = SEGMENTS[value] || [0, 0, 0, 0, 0, 0, 0];
          
          const dPaths = [
            "M 16,10 L 22,4 L 78,4 L 84,10 L 78,16 L 22,16 Z", // A
            "M 90,16 L 96,22 L 96,42 L 90,48 L 84,42 L 84,22 Z", // B
            "M 90,52 L 96,58 L 96,78 L 90,84 L 84,78 L 84,58 Z", // C
            "M 16,90 L 22,84 L 78,84 L 84,90 L 78,96 L 22,96 Z", // D
            "M 10,52 L 4,58 L 4,78 L 10,84 L 16,78 L 16,58 Z", // E
            "M 10,16 L 4,22 L 4,42 L 10,48 L 16,42 L 16,22 Z", // F
            "M 16,50 L 22,44 L 78,44 L 84,50 L 78,56 L 22,56 Z"  // G
          ];

          return (
            <svg className={className} viewBox="0 0 100 100">
              {dPaths.map((d, i) => (
                <path 
                  key={i} 
                  d={d} 
                  fill={activeSegments[i] ? color : inactiveColor} 
                  stroke="none"
                  style={{ transition: 'fill 0.2s ease' }}
                />
              ))}
            </svg>
          );
        };

        const SevenSegmentColon = ({ color = '#111827', className }) => (
          <svg className={className} viewBox="0 0 40 100">
            <rect x="10" y="25" width="20" height="20" rx="4" fill={color} />
            <rect x="10" y="65" width="20" height="20" rx="4" fill={color} />
          </svg>
        );

        // --- 隐形下拉选单组件 ---
        const InvisibleSelect = ({ value, options, onChange, disabled }) => (
          <select 
            value={value} 
            onChange={(e) => onChange(parseInt(e.target.value, 10))}
            disabled={disabled}
            className={`
              absolute inset-0 w-full h-full opacity-0 z-20 
              ${disabled ? 'cursor-default' : 'cursor-pointer'}
              appearance-none text-center
            `}
            style={{ textAlignLast: 'center', textAlign: 'center' }}
          >
            {options.map((opt) => (
              <option key={opt} value={opt}>
                {opt.toString().padStart(2, '0')}
              </option>
            ))}
          </select>
        );

        // --- 拉霸开关组件 ---
        const ToggleSwitch = ({ label, icon: Icon, checked, onChange, disabled, fontSize = "text-xs" }) => (
          <div className={`flex items-center justify-between p-1.5 rounded-lg transition-colors ${checked ? 'bg-indigo-50' : 'bg-white/50'} ${disabled ? 'opacity-50 cursor-not-allowed' : ''}`}>
            <div className="flex items-center gap-2">
              <span className={`${fontSize} font-bold ${checked ? 'text-indigo-900' : 'text-slate-600'}`}>{label}</span>
            </div>
            <button 
              onClick={() => !disabled && onChange(!checked)}
              className={`relative w-9 h-5 rounded-full transition-colors duration-200 ease-in-out focus:outline-none ${checked ? 'bg-indigo-500' : 'bg-slate-300'} ${disabled ? 'cursor-not-allowed' : 'cursor-pointer'}`}
            >
              <div 
                className={`absolute top-1 left-1 bg-white w-3 h-3 rounded-full shadow-sm transform transition-transform duration-200 ease-in-out ${checked ? 'translate-x-4' : 'translate-x-0'}`} 
              />
            </button>
          </div>
        );

        // --- 独立出的 AnalogClock 元件 ---
        const AnalogClock = React.memo(({
          totalSeconds,
          unlinkedTime, 
          onTimeChange,
          onUnlinkedChange, 
          isLinked,
          showHands,
          tickOptions,
          showDashLines,
          showColorSegments,
          inputMode,
          clockMode,
          setClockMode,
          showDurationHighlight, 
          currentScenario,       
          isChallengeMode,
          showTrace,             
          traceAnchor,
          handleTraceToggle,
          setShowDashLines,
          setShowColorSegments,
          setSpecificTime
        }) => {
          const canvasRef = useRef(null);
          const [draggedHand, setDraggedHand] = useState(null); 
          const [hoverHand, setHoverHand] = useState(null);     

          // 计算指针角度与长度
          const getHandGeometry = useCallback((width, height) => {
            const maxRadius = Math.min(width, height) / 2;
            const faceRadius = maxRadius - 10;
            const tickRadius = faceRadius - 35;
            
            let sAngle, mAngle, hAngle;

            if (isLinked) {
                const s = totalSeconds % 60;
                const mTotal = totalSeconds / 60;
                
                sAngle = (s * 6) * Math.PI / 180;
                mAngle = (mTotal % 60) * 6 * Math.PI / 180;
                
                const hTotal = totalSeconds / 3600;
                hAngle = (hTotal % 12) * 30 * Math.PI / 180;
            } else {
                sAngle = (unlinkedTime.s * 6) * Math.PI / 180;
                mAngle = (unlinkedTime.m * 6) * Math.PI / 180;
                hAngle = (unlinkedTime.h * 30) * Math.PI / 180;
            }

            return {
              center: { x: width/2, y: height/2 },
              hands: {
                h: { angle: hAngle, length: tickRadius * 0.55 },
                m: { angle: mAngle, length: tickRadius * 0.85 },
                s: { angle: sAngle, length: tickRadius * 0.9 }
              },
              faceRadius,
              tickRadius
            };
          }, [totalSeconds, unlinkedTime, isLinked]);

          const drawClock = useCallback(() => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d');
            const { width, height } = canvas;
            const centerX = width / 2;
            const centerY = height / 2;
            const maxRadius = Math.min(width, height) / 2;
            const faceRadius = maxRadius - 10; 
            const tickRadius = faceRadius - 35; 

            ctx.clearRect(0, 0, width, height);

            // 外框
            ctx.beginPath();
            ctx.arc(centerX, centerY, faceRadius + 10, 0, 2 * Math.PI);
            ctx.fillStyle = 'rgba(0,0,0,0.1)';
            ctx.fill();
            const gradient = ctx.createLinearGradient(centerX - faceRadius, centerY - faceRadius, centerX + faceRadius, centerY + faceRadius);
            gradient.addColorStop(0, '#f0f0f0');
            gradient.addColorStop(0.5, '#d0d0d0');
            gradient.addColorStop(1, '#a0a0a0');
            ctx.beginPath();
            ctx.arc(centerX, centerY, faceRadius + 8, 0, 2 * Math.PI);
            ctx.fillStyle = gradient;
            ctx.fill();
            ctx.strokeStyle = '#999';
            ctx.lineWidth = 1;
            ctx.stroke();

            // 钟面背景
            ctx.beginPath();
            ctx.arc(centerX, centerY, faceRadius, 0, 2 * Math.PI);
            const isDigitalMode = inputMode === 'digital' && clockMode === 'manual';
            ctx.fillStyle = isDigitalMode ? '#f8fafc' : '#ffffff'; 
            ctx.fill();
             
            // 整点铺色 (底层)
            if (showColorSegments) {
              ctx.save();
              ctx.beginPath();
              for (let i = 0; i < 12; i += 2) {
                const startAngle = (i * 30 - 90) * Math.PI / 180;
                const endAngle = ((i + 1) * 30 - 90) * Math.PI / 180;
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, tickRadius, startAngle, endAngle);
                ctx.lineTo(centerX, centerY);
              }
              ctx.fillStyle = '#FFF9C4'; 
              ctx.fill();
              ctx.restore();
            }

            // 练习模式：操作轨迹显示 (Draw BEFORE hands)
            if (!isChallengeMode && showTrace && traceAnchor !== null && isLinked) {
                const diff = totalSeconds - traceAnchor;
                const absDiff = Math.abs(diff);
                const isClockwise = diff >= 0;

                // A. Hour Hand Trace (Pale Pink, Solid Arc)
                if (absDiff > 0 && absDiff < 43200) {
                    const startH_Sec = traceAnchor % 43200;
                    const endH_Sec = totalSeconds % 43200;
                    
                    const startAngleH = (startH_Sec / 43200) * 2 * Math.PI - Math.PI / 2;
                    let endAngleH = (endH_Sec / 43200) * 2 * Math.PI - Math.PI / 2;
                    
                    if (isClockwise && endAngleH < startAngleH) endAngleH += 2 * Math.PI;
                    if (!isClockwise && endAngleH > startAngleH) endAngleH -= 2 * Math.PI;

                    if (Math.abs(startAngleH - endAngleH) > 0.001) {
                       ctx.save();
                       ctx.beginPath();
                       ctx.moveTo(centerX, centerY);
                       ctx.arc(centerX, centerY, tickRadius * 0.55, startAngleH, endAngleH, !isClockwise); 
                       ctx.lineTo(centerX, centerY);
                       ctx.fillStyle = 'rgba(244, 114, 182, 0.6)'; // Pale Pink
                       ctx.fill();
                       ctx.restore();
                    }
                }

                // B. Minute Hand Trace (Pale Blue, Segmented Blocks)
                if (absDiff > 0 && absDiff < 3600) {
                    const startMTotal = Math.floor(traceAnchor / 60);
                    const endMTotal = Math.round(totalSeconds / 60);
                    
                    const count = Math.abs(endMTotal - startMTotal);
                    const safeCount = Math.min(count, 60);
                    const dir = endMTotal > startMTotal ? 1 : -1;

                    ctx.save();
                    for (let i = 0; i < safeCount; i++) {
                        const mIdx = startMTotal + (dir === 1 ? i : -(i+1)); 
                        const normalizedM = ((mIdx % 60) + 60) % 60;
                        const gap = 0.02; 
                        
                        const blockStartAngle = (normalizedM * 6 - 90) * Math.PI / 180 + gap;
                        const blockEndAngle = ((normalizedM + 1) * 6 - 90) * Math.PI / 180 - gap;
                        
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, tickRadius, blockStartAngle, blockEndAngle, false);
                        ctx.arc(centerX, centerY, tickRadius - 25, blockEndAngle, blockStartAngle, true); 
                        ctx.closePath();
                        ctx.fillStyle = 'rgba(96, 165, 250, 0.6)'; // Pale Blue
                        ctx.fill();
                    }
                    ctx.restore();
                }
            }

            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            
            // Draw Ticks & Numbers (BEFORE hands)
            for (let i = 0; i < 60; i++) {
              const angle = (i * 6 - 90) * Math.PI / 180;
              const isHourMark = i % 5 === 0;
              const tickLen = isHourMark ? 15 : 6;
              const tickW = isHourMark ? 4 : 1.5;
              const tickColor = isHourMark ? '#333' : '#999';

              const x1 = centerX + Math.cos(angle) * (tickRadius - tickLen);
              const y1 = centerY + Math.sin(angle) * (tickRadius - tickLen);
              const x2 = centerX + Math.cos(angle) * tickRadius; 
              const y2 = centerY + Math.sin(angle) * tickRadius;

              ctx.beginPath();
              ctx.moveTo(x1, y1);
              ctx.lineTo(x2, y2);
              ctx.strokeStyle = tickColor;
              ctx.lineWidth = tickW;
              ctx.lineCap = 'round';
              ctx.stroke();

              // A. 时针数字 (内圈)
              if (isHourMark && tickOptions.hour) {
                  const hVal = i === 0 ? 12 : i / 5;
                  const textR = tickRadius - 40; 
                  const tx = centerX + Math.cos(angle) * textR;
                  const ty = centerY + Math.sin(angle) * textR;
                  ctx.font = 'bold 36px "Noto Sans TC", sans-serif';
                  ctx.fillStyle = '#DC2626'; // Red
                  ctx.fillText(hVal.toString(), tx, ty + 1); 
              }

              // B. 分针数字 (外圈)
              if (isHourMark && (tickOptions.min5 || tickOptions.min1)) {
                 let minText = (i===0 ? 60 : i).toString();
                 let r = tickRadius + 22;
                 let fs = tickOptions.min5 ? 'bold 18px "Noto Sans TC"' : 'bold 16px "Noto Sans TC"';
                 ctx.font = fs;
                 ctx.fillStyle = '#2563EB'; // Blue
                 ctx.fillText(minText, centerX + Math.cos(angle)*r, centerY + Math.sin(angle)*r + 1);
              } else if (!isHourMark && tickOptions.min1) {
                 ctx.font = '12px "Noto Sans TC"';
                 ctx.fillStyle = '#2563EB'; // Blue
                 ctx.fillText(i.toString(), centerX + Math.cos(angle)*(tickRadius+22), centerY + Math.sin(angle)*(tickRadius+22) + 1);
              }
            }

            const { hands } = getHandGeometry(width, height);

            // Helper to draw standard pointer (Rounded)
            const drawPointer = (rotation, len, baseW, color, type) => {
              ctx.save();
              ctx.translate(centerX, centerY);
              ctx.rotate(rotation); 
              
              if (showDashLines) {
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -tickRadius);
                ctx.strokeStyle = color;
                ctx.lineWidth = 1.5;
                ctx.setLineDash([6, 4]);
                ctx.stroke();
                ctx.setLineDash([]);
              }
              
              const r = baseW / 2;
              ctx.beginPath();
              ctx.moveTo(r, 15);
              ctx.lineTo(r, -len + r);
              ctx.arc(0, -len + r, r, 0, Math.PI, true);
              ctx.lineTo(-r, 15);
              ctx.closePath();
              
              const isInteraction = (draggedHand === type) || (hoverHand === type && !draggedHand);
              if (isInteraction) {
                 ctx.shadowColor = 'rgba(0,0,0,0.4)';
                 ctx.shadowBlur = 15;
              } else {
                 ctx.shadowColor = 'rgba(0,0,0,0.2)';
                 ctx.shadowBlur = 5;
              }
              
              ctx.fillStyle = (inputMode === 'digital' && clockMode === 'manual') ? '#999' : color; 
              ctx.fill();
              ctx.shadowColor = 'transparent';
              ctx.shadowBlur = 0;
              ctx.restore();
            };

            // Draw Hands (TOP LAYER)
            if (showHands.hour) drawPointer(hands.h.angle, hands.h.length, 14, '#DC2626', 'h');
            if (showHands.minute) drawPointer(hands.m.angle, hands.m.length, 10, '#2563EB', 'm');
            
            if (showHands.second) {
              ctx.save();
              ctx.translate(centerX, centerY);
              ctx.rotate(hands.s.angle);
              
              if (showDashLines) {
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(0, -tickRadius);
                ctx.strokeStyle = '#666'; 
                ctx.lineWidth = 1;
                ctx.setLineDash([6, 4]);
                ctx.stroke();
                ctx.setLineDash([]);
              }

              const secW = 4;
              const secR = secW / 2;
              const secLen = tickRadius * 0.9;
              
              ctx.beginPath();
              ctx.moveTo(secR, 15);
              ctx.lineTo(secR, -secLen + secR);
              ctx.arc(0, -secLen + secR, secR, 0, Math.PI, true);
              ctx.lineTo(-secR, 15);
              ctx.arc(0, 15, secR, Math.PI, 0, true);
              ctx.closePath();
              
              const isInteraction = (draggedHand === 's') || (hoverHand === 's' && !draggedHand);
              if (isInteraction) {
                 ctx.shadowColor = 'rgba(0,0,0,0.4)';
                 ctx.shadowBlur = 15;
              } else {
                 ctx.shadowColor = 'rgba(0,0,0,0.2)';
                 ctx.shadowBlur = 4;
              }

              ctx.fillStyle = (inputMode === 'digital' && clockMode === 'manual') ? '#AAA' : '#000';
              ctx.fill();
              ctx.shadowColor = 'transparent';
              ctx.shadowBlur = 0;
              ctx.restore();
            }

            // Center Cap (Absolute Top)
            ctx.beginPath();
            ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
            const gradCenter = ctx.createRadialGradient(centerX - 2, centerY - 2, 1, centerX, centerY, 8);
            gradCenter.addColorStop(0, '#fff');
            gradCenter.addColorStop(1, '#666');
            ctx.fillStyle = gradCenter;
            ctx.fill();

          }, [totalSeconds, unlinkedTime, isLinked, getHandGeometry, showHands, tickOptions, showDashLines, showColorSegments, inputMode, clockMode, draggedHand, hoverHand, showTrace, traceAnchor, isChallengeMode, showDurationHighlight, currentScenario]);

          useEffect(() => {
            drawClock();
          }, [drawClock]);

          // --- Smart Hit Testing ---
          const checkHit = (ex, ey) => {
            const canvas = canvasRef.current;
            if (!canvas) return null;
            const rect = canvas.getBoundingClientRect();
            
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            
            const x = (ex - rect.left) * scaleX - canvas.width / 2;
            const y = (ey - rect.top) * scaleY - canvas.height / 2;
            
            const r = Math.sqrt(x*x + y*y);
            let angle = Math.atan2(y, x) + Math.PI/2; 
            if (angle < 0) angle += Math.PI * 2;

            const { hands } = getHandGeometry(canvas.width, canvas.height);
            
            if (r < 15) return null;

            const getHandDistance = (handAngle) => {
                let diff = Math.abs(angle - handAngle % (Math.PI*2));
                if (diff > Math.PI) diff = 2*Math.PI - diff;
                return Math.abs(r * Math.sin(diff));
            };

            let candidates = [];
            const hitWidth = 15;
            const tipBuffer = 15;

            if (showHands.second) {
                const d = getHandDistance(hands.s.angle);
                if (d < hitWidth && r <= hands.s.length + tipBuffer) {
                    candidates.push({ type: 's', dist: d, z: 3 });
                }
            }
            if (showHands.minute) {
                const d = getHandDistance(hands.m.angle);
                if (d < hitWidth && r <= hands.m.length + tipBuffer) {
                    candidates.push({ type: 'm', dist: d, z: 2 });
                }
            }
            if (showHands.hour) {
                const d = getHandDistance(hands.h.angle);
                if (d < 20 && r <= hands.h.length + tipBuffer) {
                    candidates.push({ type: 'h', dist: d, z: 1 });
                }
            }

            if (candidates.length === 0) return null;
            candidates.sort((a, b) => {
                if (Math.abs(a.dist - b.dist) < 5) {
                    return b.z - a.z;
                }
                return a.dist - b.dist; 
            });

            return candidates[0].type;
          };

          const computeNewTime = (handType, angle, currentSeconds) => {
            let newTotalSeconds = currentSeconds;
            if (isLinked) {
                if (handType === 'm') {
                    const minutesVal = (angle / (Math.PI * 2)) * 60;
                    const currentM = (currentSeconds / 60) % 60;
                    let diff = minutesVal - currentM;
                    if (diff > 30) diff -= 60;
                    if (diff < -30) diff += 60;
                    newTotalSeconds += diff * 60;
                    newTotalSeconds = Math.round(newTotalSeconds / 60) * 60;
                } else if (handType === 'h') {
                    const hoursVal = (angle / (Math.PI * 2)) * 12;
                    let currentTotalH = currentSeconds / 3600;
                    let currentH12 = currentTotalH % 12;
                    let diff = hoursVal - currentH12;
                    if (diff > 6) diff -= 12;
                    if (diff < -6) diff += 12;
                    newTotalSeconds += diff * 3600;
                    newTotalSeconds = Math.round(newTotalSeconds / 60) * 60;
                } else if (handType === 's') {
                    const secondsVal = (angle / (Math.PI * 2)) * 60;
                    const currentS = currentSeconds % 60;
                    let diff = secondsVal - currentS;
                    if (diff > 30) diff -= 60;
                    if (diff < -30) diff += 60;
                    newTotalSeconds += diff; 
                    newTotalSeconds = Math.round(newTotalSeconds);
                }
            } else {
                if (handType === 'h') {
                     let newH = (angle / (Math.PI * 2)) * 12;
                     let oldH = currentSeconds / 3600; 
                     let isPM = (Math.floor(oldH) % 24) >= 12;
                     newH = newH % 12; 
                     if (newH < 0) newH += 12;
                     if (isPM) newH += 12;
                     onUnlinkedChange(prev => ({ ...prev, h: newH }));
                     return currentSeconds; 
                } else if (handType === 'm') {
                     let newM = (angle / (Math.PI * 2)) * 60;
                     if (newM < 0) newM += 60;
                     if (newM >= 60) newM -= 60;
                     onUnlinkedChange(prev => ({ ...prev, m: newM }));
                     return currentSeconds;
                } else if (handType === 's') {
                     let newS = (angle / (Math.PI * 2)) * 60;
                     if (newS < 0) newS += 60;
                     if (newS >= 60) newS -= 60;
                     onUnlinkedChange(prev => ({ ...prev, s: newS }));
                     return currentSeconds;
                }
            }
            if (newTotalSeconds < 0) newTotalSeconds += 86400;
            if (newTotalSeconds >= 86400) newTotalSeconds %= 86400;
            return newTotalSeconds; 
          };

          const handleStart = (e) => {
            if (inputMode === 'digital') return;
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;
            
            const hit = checkHit(clientX, clientY);
            if (hit) {
              setDraggedHand(hit);
              setClockMode('manual');
            }
          };

          const handleMove = (e) => {
            const clientX = e.clientX || e.touches[0].clientX;
            const clientY = e.clientY || e.touches[0].clientY;

            if (inputMode === 'analog') {
                const hit = checkHit(clientX, clientY);
                setHoverHand(hit);
            } else {
                setHoverHand(null);
            }

            if (!draggedHand) return;
            e.preventDefault();
            
            const canvas = canvasRef.current;
            const rect = canvas.getBoundingClientRect();
            
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (clientX - rect.left) * scaleX - canvas.width / 2;
            const y = (clientY - rect.top) * scaleY - canvas.height / 2;
            
            let angle = Math.atan2(y, x); 
            angle += Math.PI / 2;
            if (angle < 0) angle += Math.PI * 2;
            
            const newTime = computeNewTime(draggedHand, angle, totalSeconds);
            if (isLinked) {
                onTimeChange(newTime);
            }
            setClockMode('manual');
          };

          const handleEnd = () => {
            setDraggedHand(null);
          };

          return (
            <div 
              style={{ cursor: draggedHand ? 'grabbing' : (hoverHand ? 'pointer' : 'default') }}
              className={`bg-white rounded-3xl shadow-xl p-4 sm:p-8 border border-slate-200 relative w-full h-full aspect-square flex items-center justify-center transition-all duration-300 ${inputMode === 'digital' && clockMode === 'manual' ? 'opacity-80 scale-[0.98]' : 'opacity-100'}`}
            >
              {inputMode === 'digital' && clockMode === 'manual' && (
                <div className={`absolute top-4 left-4 px-3 py-1 rounded-full text-xs font-bold border flex items-center gap-1 transition-colors bg-slate-100 text-slate-400 border-slate-200`}>
                  <MousePointer2 className="w-3 h-3" />
                  指针已锁定
                </div>
              )}
              
              <div className="hidden sm:flex absolute top-2 left-2 sm:top-4 sm:left-4 flex-col items-start gap-2 z-20">
                <div className="bg-white/90 backdrop-blur-sm p-1.5 rounded-xl border border-slate-200 shadow-md">
                   <ToggleSwitch label="轨迹" checked={showTrace} onChange={handleTraceToggle} disabled={clockMode !== 'manual'} />
                </div>
              </div>

              <div className="hidden sm:flex absolute bottom-2 left-2 sm:bottom-4 sm:left-4 flex-col items-start gap-2 z-20">
                <div className="bg-white/90 backdrop-blur-sm p-1.5 rounded-xl border border-slate-200 shadow-md">
                   <ToggleSwitch label="虚线" checked={showDashLines} onChange={setShowDashLines} />
                </div>
              </div>
              
              <div className="hidden sm:flex absolute top-2 right-2 sm:top-4 sm:right-4 flex-col items-end gap-2 z-20">
                <div className="bg-white/90 backdrop-blur-sm p-1.5 rounded-xl border border-slate-200 shadow-md">
                   <ToggleSwitch label="色块" checked={showColorSegments} onChange={setShowColorSegments} />
                </div>
              </div>

               <div className="hidden sm:flex absolute bottom-2 right-2 sm:bottom-4 sm:right-4 flex-col items-end gap-2 z-20">
                <div className="bg-white/90 backdrop-blur-sm p-2 rounded-xl border border-slate-200 shadow-md w-32">
                   <div className="px-1">
                        <input 
                            type="range" 
                            min="3" 
                            max="12" 
                            step="3" 
                            onChange={(e) => setSpecificTime(parseInt(e.target.value))}
                            className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-indigo-600"
                        />
                        <div className="flex justify-between text-[10px] text-slate-400 font-bold mt-1 px-1">
                            <span>3</span>
                            <span>6</span>
                            <span>9</span>
                            <span>12</span>
                        </div>
                    </div>
                </div>
              </div>

              <canvas
                ref={canvasRef}
                width={500}
                height={500}
                className={`w-full h-full touch-none aspect-square lg:aspect-auto lg:h-full`}
                onMouseDown={handleStart}
                onMouseMove={handleMove}
                onMouseUp={handleEnd}
                onMouseLeave={() => { handleEnd(); setHoverHand(null); }}
                onTouchStart={handleStart}
                onTouchMove={handleMove}
                onTouchEnd={handleEnd}
              />
            </div>
          );
        });

        const ClockApp = () => {
          const [totalSeconds, setTotalSeconds] = useState(21600); 
          const [unlinkedTime, setUnlinkedTime] = useState({ h: 6, m: 0, s: 0 });
          const [unlinkedIsPM, setUnlinkedIsPM] = useState(false);
          
          const [clockMode, setClockMode] = useState('manual'); 
          const [inputMode, setInputMode] = useState('analog'); 
          
          const [isLinked, setIsLinked] = useState(true);
          const [showHands, setShowHands] = useState({ hour: true, minute: true, second: false });
          const [tickOptions, setTickOptions] = useState({ hour: true, min5: false, min1: false });
          const [showDashLines, setShowDashLines] = useState(false);
          const [showColorSegments, setShowColorSegments] = useState(false); 
          const [is24Hour, setIs24Hour] = useState(false);
          
          const [showTrace, setShowTrace] = useState(false);
          const [traceAnchor, setTraceAnchor] = useState(null); 

          const handleLinkToggle = (newVal) => {
            setIsLinked(newVal);
            if (!newVal) {
                const h = (totalSeconds / 3600) % 12; 
                const m = (totalSeconds / 60) % 60;
                const s = totalSeconds % 60;
                const isPM = (Math.floor(totalSeconds / 3600) % 24) >= 12;
                setUnlinkedTime({ h, m, s });
                setUnlinkedIsPM(isPM);
            } else {
                const hInt = Math.floor(unlinkedTime.h);
                const mVal = unlinkedTime.m;
                const sVal = unlinkedTime.s;
                let newH = hInt % 12;
                if (unlinkedIsPM) newH += 12; 
                const newTotal = newH * 3600 + mVal * 60 + sVal;
                setTotalSeconds(Math.round(newTotal) % 86400);
            }
          };

          const handleTraceToggle = (checked) => {
            setShowTrace(checked);
            if (checked) {
              setTraceAnchor(totalSeconds);
            } else {
              setTraceAnchor(null);
            }
          };

          useEffect(() => {
            let intervalId;
            if (clockMode === 'now') {
              const updateToNow = () => {
                const now = new Date();
                const s = now.getHours() * 3600 + now.getMinutes() * 60 + now.getSeconds();
                setTotalSeconds(s);
                if (!isLinked) {
                     setUnlinkedTime({ 
                         h: (s / 3600) % 12, 
                         m: (s / 60) % 60, 
                         s: s % 60 
                     });
                     setUnlinkedIsPM(now.getHours() >= 12);
                }
              };
              updateToNow(); 
              intervalId = setInterval(updateToNow, 1000);
            }
            return () => {
              if (intervalId) clearInterval(intervalId);
            };
          }, [clockMode, isLinked]);

          const setNow = () => {
            setClockMode('now');
          };
          
          const resetClock = () => {
            const startSec = 21600; 
            setTotalSeconds(startSec);
            setUnlinkedTime({ h: 6, m: 0, s: 0 });
            setUnlinkedIsPM(false);
            setClockMode('manual');
            if (showTrace) setTraceAnchor(startSec); 
  
          };

          const setSpecificTime = (h) => {
            const newTotal = h * 3600;
            setTotalSeconds(newTotal);
            setClockMode('manual');
            setUnlinkedTime({ h: h, m: 0, s: 0 });
            setUnlinkedIsPM(h >= 12); 
            if (showTrace) setTraceAnchor(newTotal);
          };
          
          let displayH, displayM, displayS, isCurrentPM;
          
          if (isLinked) {
              let totalS = totalSeconds % 86400;
              if (totalS < 0) totalS += 86400;
              const rawH = Math.floor(totalS / 3600);
              const rawM = Math.floor((totalS % 3600) / 60);
              const rawS = Math.floor(totalS % 60);
              isCurrentPM = (rawH % 24) >= 12;
              displayH = is24Hour ? rawH : (rawH % 12 || 12);
              displayM = rawM;
              displayS = rawS;
          } else {
              const rawH = Math.floor(unlinkedTime.h) % 12; 
              const rawM = Math.floor(unlinkedTime.m);
              const rawS = Math.floor(unlinkedTime.s);
              isCurrentPM = unlinkedIsPM;
              if (is24Hour) {
                  displayH = rawH + (isCurrentPM ? 12 : 0);
              } else {
                  displayH = rawH === 0 ? 12 : rawH;
              }
              displayM = rawM;
              displayS = rawS;
          }

          const h1 = Math.floor(displayH / 10);
          const h2 = displayH % 10;
          const m1 = Math.floor(displayM / 10);
          const m2 = displayM % 10;
          const s1 = Math.floor(displayS / 10);
          const s2 = displayS % 10;

          const showDigitalControls = inputMode === 'digital' && clockMode === 'manual';
          const finalHourOptions = is24Hour ? Array.from({length: 24}, (_, i) => i) : [12, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11];
          const minSecOptions = Array.from({length: 60}, (_, i) => i);

          const updateHour = (newHourVal) => {
              if (isLinked) {
                let m = Math.floor(totalSeconds / 60) % 60;
                let s = totalSeconds % 60;
                let newH = newHourVal;
                if (!is24Hour) {
                   const currentH = Math.floor(totalSeconds / 3600);
                   const wasPM = (currentH % 24) >= 12;
                   if (newH === 12) newH = 0; 
                   if (wasPM) newH += 12;
                }
                setTotalSeconds(newH * 3600 + m * 60 + s);
              } else {
                let targetH = newHourVal;
                if (!is24Hour && newHourVal === 12) targetH = 0;
                
                setUnlinkedTime(prev => ({ ...prev, h: targetH }));
                if (is24Hour) {
                    setUnlinkedIsPM(newHourVal >= 12);
                }
              }
              setClockMode('manual');
          };

          const updateMinute = (newMinVal) => {
              if (isLinked) {
                let h = Math.floor(totalSeconds / 3600);
                let s = totalSeconds % 60;
                setTotalSeconds(h * 3600 + newMinVal * 60 + s);
              } else {
                setUnlinkedTime(prev => ({ ...prev, m: newMinVal }));
              }
              setClockMode('manual');
          };

          const updateSecond = (newSecVal) => {
              if (isLinked) {
                let h = Math.floor(totalSeconds / 3600);
                let m = Math.floor(totalSeconds / 60) % 60;
                setTotalSeconds(h * 3600 + m * 60 + newSecVal);
              } else {
                setUnlinkedTime(prev => ({ ...prev, s: newSecVal }));
              }
              setClockMode('manual');
          };
          
          const setAM = () => {
            if (isLinked) {
                setTotalSeconds(prev => {
                  const h = Math.floor(prev / 3600);
                  const isPM = (h % 24) >= 12;
                  if (isPM) return prev - 12 * 3600;
                  return prev;
                });
            } else {
                setUnlinkedIsPM(false);
            }
            setClockMode('manual');
          };

          const setPM = () => {
            if (isLinked) {
                setTotalSeconds(prev => {
                  const h = Math.floor(prev / 3600);
                  const isPM = (h % 24) >= 12;
                  if (!isPM) return prev + 12 * 3600;
                  return prev;
                });
            } else {
                setUnlinkedIsPM(true);
            }
            setClockMode('manual');
          };

          const toggleTickOption = (key) => {
            setTickOptions(prev => ({ ...prev, [key]: !prev[key] }));
          };

          const clearTickOptions = () => {
            setTickOptions({ hour: false, min5: false, min1: false });
          };

          const hasAnyTick = tickOptions.hour || tickOptions.min5 || tickOptions.min1;

          return (
            <div className="min-h-screen bg-slate-100 font-sans select-none overflow-x-hidden flex justify-center">
              <div className="w-full max-w-7xl transition-transform duration-300 lg:scale-75 lg:origin-top">
                <div className="p-4 pb-12">
                  <div className="grid grid-cols-1 lg:grid-cols-12 gap-3 mb-3">
                    <div className="lg:col-span-12 bg-white rounded-xl shadow-sm border border-slate-200 p-4 flex items-center justify-center gap-5">
                      <div className="text-center">
                        <h1 className="text-4xl sm:text-4xl font-bold text-slate-800 tracking-tight">时钟转转乐</h1>
                        <p className="text-lg text-slate-500 mt-1">互动式数位教具 | 适用年级：低年级</p>
                      </div>
                    </div>
                  </div>

                  <div className="grid grid-cols-1 lg:grid-cols-12 gap-3 items-stretch">
                    <div className="lg:col-span-7 flex flex-col">
                        <div className="block sm:hidden w-full bg-white p-3 mb-3 rounded-xl shadow-md border border-slate-200">
                             <div className="grid grid-cols-2 gap-3 mb-3">
                                <div className="flex flex-col gap-2">
                                     <ToggleSwitch label="轨迹" checked={showTrace} onChange={handleTraceToggle} disabled={clockMode !== 'manual'} />
                                     <ToggleSwitch label="虚线" checked={showDashLines} onChange={setShowDashLines} />
                                </div>
                                <div className="flex flex-col gap-2">
                                     <ToggleSwitch label="色块" checked={showColorSegments} onChange={setShowColorSegments} />
                                </div>
                             </div>
                             <div className="px-1 pt-1 border-t border-slate-100">
                                <input 
                                    type="range" 
                                    min="3" 
                                    max="12" 
                                    step="3" 
                                    onChange={(e) => setSpecificTime(parseInt(e.target.value))}
                                    className="w-full h-2 bg-slate-200 rounded-lg appearance-none cursor-pointer accent-indigo-600"
                                />
                                <div className="flex justify-between text-[10px] text-slate-400 font-bold mt-1 px-1">
                                    <span>3</span>
                                    <span>6</span>
                                    <span>9</span>
                                    <span>12</span>
                                </div>
                             </div>
                        </div>

                       <div className="w-full h-full flex items-center justify-center bg-white rounded-3xl shadow-xl p-4 sm:p-8 border border-slate-200 relative lg:h-full">
                        <AnalogClock 
                          totalSeconds={totalSeconds}
                          unlinkedTime={unlinkedTime}
                          onTimeChange={setTotalSeconds}
                          onUnlinkedChange={setUnlinkedTime}
                          isLinked={isLinked}
                          showHands={showHands}
                          tickOptions={tickOptions}
                          showDashLines={showDashLines}
                          showColorSegments={showColorSegments}
                          inputMode={inputMode}
                          clockMode={clockMode}
                          setClockMode={setClockMode}
                          showTrace={showTrace}
                          traceAnchor={traceAnchor}
                          handleTraceToggle={handleTraceToggle}
                          setShowDashLines={setShowDashLines}
                          setShowColorSegments={setShowColorSegments}
                          setSpecificTime={setSpecificTime}
                        />
                      </div>
                    </div>

                    <div className="lg:col-span-5 flex flex-col gap-3 h-full">
                       <div className="w-full bg-white rounded-xl shadow-md border border-slate-200 p-4 flex flex-col items-center justify-center shrink-0">
                          <div className="w-full bg-slate-100 px-2 py-4 rounded-xl border-2 border-slate-200 flex flex-col items-center justify-center gap-4 shadow-inner relative">
                              <div className="flex items-center gap-1 z-10 transition-transform">
                                 <div className="relative group">
                                    <div className={`flex gap-0.5 sm:gap-1 transition-all duration-200 rounded p-0.5 ${showDigitalControls ? 'cursor-pointer hover:bg-slate-200/50 ring-2 ring-transparent hover:ring-indigo-200' : ''}`}>
                                        <SevenSegmentDigit value={h1} className="w-6 h-12 sm:w-10 sm:h-20 lg:w-16 lg:h-32" color="#1e293b" inactiveColor="#e2e8f0" />
                                        <SevenSegmentDigit value={h2} className="w-6 h-12 sm:w-10 sm:h-20 lg:w-16 lg:h-32" color="#1e293b" inactiveColor="#e2e8f0" />
                                    </div>
                                    {showDigitalControls && (
                                      <InvisibleSelect value={displayH} options={finalHourOptions} onChange={updateHour} />
                                    )}
                                 </div>

                                 <div className="flex flex-col items-center gap-1">
                                    <SevenSegmentColon className="w-2 h-12 sm:w-4 sm:h-20 lg:w-4 lg:h-32 opacity-80" color="#1e293b" />
                                 </div>

                                 <div className="relative group">
                                    <div className={`flex gap-0.5 sm:gap-1 transition-all duration-200 rounded p-0.5 ${showDigitalControls ? 'cursor-pointer hover:bg-slate-200/50 ring-2 ring-transparent hover:ring-indigo-200' : ''}`}>
                                        <SevenSegmentDigit value={m1} className="w-6 h-12 sm:w-10 sm:h-20 lg:w-16 lg:h-32" color="#1e293b" inactiveColor="#e2e8f0" />
                                        <SevenSegmentDigit value={m2} className="w-6 h-12 sm:w-10 sm:h-20 lg:w-16 lg:h-32" color="#1e293b" inactiveColor="#e2e8f0" />
                                    </div>
                                    {showDigitalControls && (
                                      <InvisibleSelect value={displayM} options={minSecOptions} onChange={updateMinute} />
                                    )}
                                 </div>

                                 {showHands.second && (
                                   <>
                                     <div className="flex flex-col items-center gap-1">
                                        <SevenSegmentColon className="w-2 h-12 sm:w-4 sm:h-20 lg:w-4 lg:h-32 opacity-80" color="#1e293b" />
                                     </div>
                                     <div className="relative group flex items-end">
                                        <div className={`flex gap-0.5 sm:gap-1 mb-1 transition-all duration-200 rounded p-0.5 ${showDigitalControls ? 'cursor-pointer hover:bg-slate-200/50 ring-2 ring-transparent hover:ring-indigo-200' : ''}`}>
                                            <SevenSegmentDigit value={s1} className="w-5 h-10 sm:w-8 sm:h-16 lg:w-14 lg:h-28 self-center" color="#1e293b" inactiveColor="#e2e8f0" />
                                            <SevenSegmentDigit value={s2} className="w-5 h-10 sm:w-8 sm:h-16 lg:w-14 lg:h-28 self-center" color="#1e293b" inactiveColor="#e2e8f0" />
                                        </div>
                                        {showDigitalControls && (
                                          <div className="absolute inset-0 mb-1">
                                             <InvisibleSelect value={displayS} options={minSecOptions} onChange={updateSecond} />
                                          </div>
                                        )}
                                     </div>
                                   </>
                                 )}
                              </div>

                               <div className="flex items-center justify-center gap-4 w-full pt-2 border-t border-slate-200 mt-2">
                                   {!is24Hour && (
                                      <div className="flex gap-1 items-center">
                                         <button onClick={setAM} className={`text-xs sm:text-sm font-bold px-3 py-1 rounded transition-colors border ${!isCurrentPM ? 'bg-red-50 text-red-600 border-red-200' : 'text-slate-400 border-transparent hover:text-slate-600'}`}>AM</button>
                                         <button onClick={setPM} className={`text-xs sm:text-sm font-bold px-3 py-1 rounded transition-colors border ${isCurrentPM ? 'bg-red-50 text-red-600 border-red-200' : 'text-slate-400 hover:text-slate-600'}`}>PM</button>
                                      </div>
                                   )}
                                   
                                   <button onClick={() => setIs24Hour(!is24Hour)} className="text-xs sm:text-sm font-bold bg-white text-slate-600 px-3 py-1 rounded border border-slate-300 hover:bg-slate-50 transition leading-none cursor-pointer">
                                        {is24Hour ? '24H 模式' : '12H 模式'}
                                   </button>
                               </div>
                          </div>
                       </div>
                      
                      <div className="bg-white rounded-xl shadow-md border border-slate-200 overflow-hidden flex-1">
                        <div className="p-3 space-y-3">
                          
                          <div className={`transition-all duration-300 ${clockMode === 'manual' ? 'opacity-100' : 'opacity-100'}`}>
                            <div className="flex items-center justify-between mb-1">
                              <span className="text-base font-bold text-slate-800">1. 操作模式</span>
                            </div>
                            <div className="flex flex-col gap-1.5">
                                <div className="grid grid-cols-2 gap-2 bg-slate-100 p-1 rounded-lg">
                                  <button 
                                    onClick={() => setInputMode('analog')} 
                                    className={`py-2 rounded-md text-sm font-bold transition flex items-center justify-center gap-2 ${inputMode === 'analog' ? 'bg-white text-indigo-600 shadow-sm' : 'text-slate-500 hover:text-slate-700'}`}
                                    disabled={clockMode !== 'manual'}
                                  >
                                    圆形钟
                                  </button>
                                  <button 
                                    onClick={() => setInputMode('digital')} 
                                    className={`py-2 rounded-md text-sm font-bold transition flex items-center justify-center gap-2 ${inputMode === 'digital' ? 'bg-white text-indigo-600 shadow-sm' : 'text-slate-500 hover:text-slate-700'}`}
                                    disabled={clockMode !== 'manual'}
                                  >
                                    电子钟
                                  </button>
                                </div>
                                
                                <div className="grid grid-cols-2 gap-2 bg-slate-100 p-1 rounded-lg">
                                  <button 
                                    onClick={setNow} 
                                    className={`py-2 rounded-md text-sm font-bold transition flex items-center justify-center gap-2 ${clockMode === 'now' ? 'bg-white text-indigo-600 shadow-sm' : 'text-slate-500 hover:text-slate-700'}`}
                                  >
                                    现在时间
                                  </button>
                                  <button 
                                    onClick={resetClock} 
                                    className={`py-2 rounded-md text-sm font-bold transition flex items-center justify-center gap-2 ${clockMode === 'manual' ? 'bg-white text-indigo-600 shadow-sm' : 'text-slate-500 hover:text-slate-700'}`}
                                  >
                                    手动操作
                                  </button>
                                </div>
                            </div>
                          </div>

                          <hr className="border-slate-100" />

                          <div className="space-y-2">
                            <div className="flex items-center justify-between mb-1">
                              <span className="text-base font-bold text-slate-800">2. 指针设定</span>
                            </div>
                            
                            <ToggleSwitch label="指针联动" checked={isLinked} onChange={handleLinkToggle} fontSize="text-sm" />

                            <div className="grid grid-cols-3 gap-2">
                              <button onClick={() => setShowHands(p => ({...p, hour: !p.hour}))} className={`flex flex-col items-center justify-center p-2 rounded-lg border-2 transition ${showHands.hour ? 'border-red-100 bg-red-50 text-red-600' : 'border-transparent bg-slate-50 text-slate-400 grayscale'}`}><div className="w-6 h-6 sm:w-8 sm:h-8 rounded-full border-2 border-current flex items-center justify-center mb-1 bg-white"><div className="w-1 h-3 bg-current rounded-full"></div></div><span className="text-xs font-bold">时针</span></button>
                              <button onClick={() => setShowHands(p => ({...p, minute: !p.minute}))} className={`flex flex-col items-center justify-center p-2 rounded-lg border-2 transition ${showHands.minute ? 'border-blue-100 bg-blue-50 text-blue-600' : 'border-transparent bg-slate-50 text-slate-400 grayscale'}`}><div className="w-6 h-6 sm:w-8 sm:h-8 rounded-full border-2 border-current flex items-center justify-center mb-1 bg-white"><div className="w-1 h-5 bg-current rounded-full"></div></div><span className="text-xs font-bold">分针</span></button>
                              <button onClick={() => setShowHands(p => ({...p, second: !p.second}))} className={`flex flex-col items-center justify-center p-2 rounded-lg border-2 transition ${showHands.second ? 'border-slate-300 bg-slate-100 text-slate-800' : 'border-transparent bg-slate-50 text-slate-400 grayscale'}`}><div className="w-6 h-6 sm:w-8 sm:h-8 rounded-full border-2 border-current flex items-center justify-center mb-1 bg-white"><div className="w-0.5 h-6 bg-current rounded-full"></div></div><span className="text-xs font-bold">秒针</span></button>
                            </div>
                          </div>
                          
                          <hr className="border-slate-100" />
                          
                          <div className="space-y-2">
                              <div className="flex items-center justify-between mb-1">
                                <span className="text-base font-bold text-slate-800">3. 数字刻度</span>
                              </div>
                              
                              <ToggleSwitch 
                                label="显示刻度" 
                                checked={hasAnyTick} 
                                onChange={(val) => val ? setTickOptions({ hour: true, min5: false, min1: false }) : clearTickOptions()} 
                                fontSize="text-sm"
                              />
                              
                              <div className="grid grid-cols-3 gap-2">
                                <button 
                                    onClick={() => toggleTickOption('hour')} 
                                    className={`flex flex-col items-center justify-center p-2 rounded-lg border-2 transition ${tickOptions.hour ? 'border-red-100 bg-red-50 text-red-600' : 'border-transparent bg-slate-50 text-slate-400 grayscale'}`}
                                >
                                    <div className="w-6 h-6 sm:w-8 sm:h-8 rounded-full border-2 border-current flex items-center justify-center mb-1 bg-white text-xs font-bold">
                                        12
                                    </div>
                                    <span className="text-xs font-bold">时针1~12</span>
                                </button>

                                <button 
                                    onClick={() => toggleTickOption('min5')} 
                                    className={`flex flex-col items-center justify-center p-2 rounded-lg border-2 transition ${tickOptions.min5 ? 'border-blue-100 bg-blue-50 text-blue-600' : 'border-transparent bg-slate-50 text-slate-400 grayscale'}`}
                                >
                                    <div className="w-6 h-6 sm:w-8 sm:h-8 rounded-full border-2 border-current flex items-center justify-center mb-1 bg-white text-xs font-bold">
                                        60
                                    </div>
                                    <span className="text-xs font-bold">分针1大格</span>
                                </button>

                                <button 
                                    onClick={() => toggleTickOption('min1')} 
                                    className={`flex flex-col items-center justify-center p-2 rounded-lg border-2 transition ${tickOptions.min1 ? 'border-blue-100 bg-blue-50 text-blue-600' : 'border-transparent bg-slate-50 text-slate-400 grayscale'}`}
                                >
                                    <div className="w-6 h-6 sm:w-8 sm:h-8 rounded-full border-2 border-current flex items-center justify-center mb-1 bg-white text-[10px] font-bold">
                                        ||||
                                    </div>
                                    <span className="text-xs font-bold">分针1小格</span>
                                </button>
                              </div>
                          </div>

                        </div>
                      </div>
                    </div>
                  </div>

                  <div className="text-center text-slate-500 text-sm mt-8 font-bold pb-8">
                    版權所有 2025 &copy;
                  </div>
                </div>
              </div>
            </div>
          );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<ClockApp />);
    </script>
</body>
</html>